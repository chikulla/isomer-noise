<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>untitled</title>
  <link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.min.css">
  <script src="node_modules/isomer/dist/isomer.min.js"></script>
</head>
<body>
<div class="container-fluid">
  <div class="row">
    <canvas height="2000" width="2000" class="col-xs-12" id="art"></canvas>
  </div>
</div>
<script>
  function indexies() {
    const len = 10;
    return Array(len).fill(0).map((v, i) => i - (len / 4)).reverse();
  }

  class RandomDot {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.before = this.randomColorHeight();
      this.after = this.randomColorHeight();
      this.resetInterval();
    }

    resetInterval() {
      this.interval = this.randomInterval();
      this.progress = 0;
    }

    randomColor() {
      return new Isomer.Color(
        this.random(100) + 20,
        this.random(150) + 50,
        this.random(50) + 100
      );
    }

    random(num) {
      return Math.floor(Math.random() * num);
    }

    randomHeight() {
      return Math.floor(Math.random() * 10) / 10;
    }


    randomColorHeight() {
      return {
        color: this.randomColor(),
        height: this.randomHeight()
      };
    }

    randomInterval() {
      return Math.floor(Math.random() * 50) + 1;
    }

    update() {
      this.progress++;
      if (this.progress >= this.interval) {
        this.before = this.after;
        this.after = this.randomColorHeight();
        this.resetInterval()
      }
    }

    currentColor() {
      return new Isomer.Color(
        this.currentValue(this.before.color.r, this.after.color.r),
        this.currentValue(this.before.color.g, this.after.color.g),
        this.currentValue(this.before.color.b, this.after.color.b),
        this.currentValue(this.before.color.a, this.after.color.a),
      );
    }

    currentHeight() {
      return this.currentValue(this.before.height, this.after.height);
    }

    currentValue(before, after) {
      const r = (after - before) / this.interval * this.progress + before;
      return r;
    }

    current() {
      this.update();
      return {
        x: this.x,
        y: this.y,
        color: this.currentColor(),
        height: this.currentHeight()
      };
    }

  }

  function addDot(iso, d) {
    iso.add(
      Isomer.Shape.Prism(
        Isomer.Point(d.x, d.y, 0),
        1,
        1,
        d.height
      ),
      d.color
    );
  }

  function main() {
    const canvas = document.getElementById('art');
    const ctx = canvas.getContext('2d');
    const iso = new Isomer(canvas);
    const xlist = indexies();
    const ylist = indexies();
    const grids = xlist.map((x) => ylist.map((y) => ({x, y}))).reduce((a, b) => a.concat(b));

    const dots = grids.map((g) => new RandomDot(g.x, g.y));

    function loop() {
      requestAnimationFrame(loop);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      dots.map((d) => d.current()).forEach((d) => {
        addDot(iso, d);
      });
    }
    requestAnimationFrame(loop);
  }

  main();
</script>
</body>
</html>